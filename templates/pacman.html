<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Num√©rifix : La R√©sistance des Donn√©es - NIRD Quest</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Comic Sans MS', 'Inter', 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #2C5F2D 0%, #1A3A1B 100%);
            color: #FFFFFF;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 2rem;
            position: relative;
            overflow-x: hidden;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                radial-gradient(2px 2px at 20% 30%, rgba(139, 195, 74, 0.3), transparent),
                radial-gradient(2px 2px at 60% 70%, rgba(139, 195, 74, 0.3), transparent);
            background-size: 200% 200%;
            animation: leaves 30s linear infinite;
            z-index: -1;
        }

        @keyframes leaves {
            0% { background-position: 0% 0%; }
            100% { background-position: 100% 100%; }
        }

        .game-container {
            max-width: 650px;
            width: 100%;
            background: rgba(139, 69, 19, 0.9);
            border: 5px solid #D2691E;
            border-radius: 20px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            padding: 2rem;
        }

        h1 {
            text-align: center;
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
            color: #FFD700;
            text-shadow: 
                2px 2px 0 #8B4513,
                3px 3px 0 #654321,
                4px 4px 10px rgba(0, 0, 0, 0.5);
            font-weight: bold;
        }

        .subtitle {
            text-align: center;
            color: #FFE4B5;
            margin-bottom: 1.5rem;
            font-size: 1.2rem;
            font-style: italic;
        }

        /* NOUVELLE SECTION : Contexte NIRD */
        .nird-context {
            margin-bottom: 1.5rem;
            padding: 1.5rem;
            background: rgba(74, 144, 226, 0.2);
            border: 3px solid #4A90E2;
            border-radius: 15px;
            box-shadow: 0 0 20px rgba(74, 144, 226, 0.3);
        }

        .nird-context h2 {
            color: #4A90E2;
            font-size: 1.4rem;
            margin-bottom: 1rem;
            text-align: center;
            text-shadow: 0 0 10px rgba(74, 144, 226, 0.5);
        }

        .nird-context p {
            color: #E8F4F8;
            line-height: 1.8;
            margin-bottom: 1rem;
            text-align: justify;
        }

        .nird-context strong {
            color: #FFD700;
        }

        .characters-roles {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin-top: 1rem;
        }

        .character-card {
            background: rgba(0, 0, 0, 0.3);
            padding: 1rem;
            border-radius: 10px;
            border: 2px solid;
        }

        .character-card.hero {
            border-color: #4A90E2;
        }

        .character-card.villain {
            border-color: #DC143C;
        }

        .character-card h3 {
            font-size: 1.1rem;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .character-card p {
            font-size: 0.9rem;
            line-height: 1.6;
            color: #E8F4F8;
        }

        .alert-box {
            background: rgba(220, 20, 60, 0.2);
            border: 3px solid #DC143C;
            border-radius: 10px;
            padding: 1rem;
            margin-top: 1rem;
            text-align: center;
        }

        .alert-box strong {
            color: #FF6B6B;
            font-size: 1.1rem;
        }

        #gameCanvas {
            display: block;
            margin: 0 auto;
            background: #1A1A1A;
            border: 5px solid #8B4513;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(139, 69, 19, 0.8), inset 0 0 50px rgba(0, 0, 0, 0.8);
            max-width: 100%;
        }

        .stats {
            display: flex;
            justify-content: space-around;
            margin-top: 1.5rem;
            padding: 1.5rem;
            background: rgba(101, 67, 33, 0.9);
            border-radius: 10px;
            border: 3px solid #D2691E;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .stat-item {
            text-align: center;
            flex: 1;
            min-width: 100px;
        }

        .stat-label {
            color: #FFE4B5;
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
            font-weight: bold;
        }

        .stat-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: #FFD700;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
        }

        .lives {
            display: flex;
            gap: 0.5rem;
            justify-content: center;
            align-items: center;
        }

        .life-icon {
            width: 25px;
            height: 25px;
            background: #FFD700;
            border-radius: 50%;
            border: 2px solid #8B4513;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.6);
        }

        .controls {
            margin-top: 1.5rem;
            padding: 1.5rem;
            background: rgba(101, 67, 33, 0.7);
            border-radius: 10px;
            text-align: center;
        }

        .controls h3 {
            color: #FFD700;
            margin-bottom: 0.8rem;
            font-size: 1.2rem;
        }

        .controls p {
            color: #FFE4B5;
            line-height: 1.8;
        }

        .btn {
            display: inline-block;
            padding: 1rem 2.5rem;
            margin: 0.5rem;
            background: linear-gradient(135deg, #D2691E, #8B4513);
            color: white;
            text-decoration: none;
            border-radius: 50px;
            font-weight: bold;
            transition: all 0.3s;
            border: 3px solid #FFD700;
            cursor: pointer;
            font-size: 1.1rem;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }

        .btn:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 10px 25px rgba(210, 105, 30, 0.5);
        }

        .btn-success {
            background: linear-gradient(135deg, #8BC34A, #558B2F);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #7F8C8D, #5D6D7E);
        }

        .game-over, .game-win {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(139, 69, 19, 0.98);
            border: 5px solid #E74C3C;
            border-radius: 20px;
            padding: 3rem;
            text-align: center;
            z-index: 1000;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.9);
            max-width: 90%;
        }

        .game-win {
            border-color: #8BC34A;
        }

        .game-over h2, .game-win h2 {
            font-size: 3rem;
            margin-bottom: 1rem;
            animation: bounce 0.5s ease;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-20px); }
        }

        .game-over h2 {
            color: #E74C3C;
        }

        .game-win h2 {
            color: #8BC34A;
        }

        .bonus-indicator {
            position: fixed;
            top: 2rem;
            right: 2rem;
            padding: 1.5rem;
            background: rgba(139, 195, 74, 0.95);
            border: 3px solid #8BC34A;
            border-radius: 15px;
            font-weight: bold;
            font-size: 1.2rem;
            display: none;
            animation: pulse 1s infinite;
            box-shadow: 0 0 30px rgba(139, 195, 74, 0.6);
            z-index: 999;
            color: #1A3A1B;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.9; transform: scale(1.05); }
        }

        .legend {
            margin-top: 1.5rem;
            padding: 1.5rem;
            background: rgba(101, 67, 33, 0.7);
            border-radius: 10px;
            font-size: 0.95rem;
            line-height: 2;
            color: #FFE4B5;
        }

        .legend strong {
            color: #FFD700;
        }

        @media (max-width: 768px) {
            body { padding: 1rem; }
            .game-container { padding: 1rem; }
            h1 { font-size: 2rem; }
            #gameCanvas { width: 100% !important; height: auto !important; }
            .bonus-indicator { top: 1rem; right: 1rem; font-size: 1rem; padding: 1rem; }
            .characters-roles { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>‚öîÔ∏è NUM√âRIFIX ‚öîÔ∏è</h1>
        <p class="subtitle">üõ°Ô∏è La R√©sistance Gauloise des Donn√©es !</p>

        <!-- NOUVELLE SECTION CONTEXTE NIRD -->
        <div class="nird-context">
            <h2>üìñ Mission : Prot√©ger la Souverainet√© Num√©rique</h2>
            <p>
                Dans le village gaulois du <strong>NIRD</strong> (Num√©rique Inclusif, Responsable et Durable), 
                les habitants stockent leurs <strong>donn√©es personnelles</strong> dans des amphores sacr√©es. 
                Ces donn√©es repr√©sentent leur <strong>vie priv√©e, leurs photos, leurs documents</strong> ‚Äî 
                tout ce qui leur appartient !
            </p>
            <p>
                Mais l'<strong style="color: #DC143C;">Empire Num√©rico</strong> (les GAFAM) veut s'emparer 
                de ces donn√©es pour les exploiter, les revendre et en tirer profit. Leurs l√©gionnaires 
                romains patrouillent pour capturer toute donn√©e qui tra√Æne...
            </p>

            <div class="characters-roles">
                <div class="character-card hero">
                    <h3>üõ°Ô∏è <span style="color: #4A90E2;">NUM√âRIFIX</span></h3>
                    <p>
                        <strong>Le H√©ros Gaulois</strong> repr√©sente <strong>l'utilisateur conscient</strong> 
                        qui prot√®ge ses donn√©es en utilisant des <strong>outils respectueux de la vie priv√©e</strong> : 
                        serveurs europ√©ens, logiciels libres, mat√©riel reconditionn√©.
                    </p>
                </div>

                <div class="character-card villain">
                    <h3>‚öîÔ∏è <span style="color: #DC143C;">LES L√âGIONNAIRES</span></h3>
                    <p>
                        <strong>L'Empire Num√©rico</strong> repr√©sente les <strong>g√©ants du Cloud √©tranger</strong> 
                        qui collectent massivement les donn√©es sans protection RGPD, les stockent hors UE, 
                        et les exploitent commercialement.
                    </p>
                </div>
            </div>

            <div class="alert-box">
                <strong>‚ö†Ô∏è ENJEU R√âEL :</strong> Chaque donn√©e perdue = une violation de vie priv√©e. 
                En perdant cette bataille, c'est ta <strong>souverainet√© num√©rique</strong> qui dispara√Æt !
            </div>
        </div>

        <canvas id="gameCanvas" width="570" height="570"></canvas>

        <div class="stats">
            <div class="stat-item">
                <div class="stat-label">üè∫ Amphores de Donn√©es</div>
                <div class="stat-value" id="dataCount">0/0</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">‚öîÔ∏è Score</div>
                <div class="stat-value" id="score">0</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">üíö Vies</div>
                <div class="lives" id="lives">
                    <div class="life-icon"></div>
                    <div class="life-icon"></div>
                    <div class="life-icon"></div>
                </div>
            </div>
        </div>

        <div class="bonus-indicator" id="bonusIndicator"></div>

        <div class="legend">
            <strong>üß™ Potions Magiques NIRD (Outils de Protection) :</strong><br>
            üîµ <strong>Potion Bleue</strong> = Serveur Europ√©en (RGPD) - Bloque temporairement les collecteurs<br>
            üü¢ <strong>Potion Verte</strong> = Logiciel Libre - Rend les collecteurs vuln√©rables (transparence du code)<br>
            üü† <strong>Potion Orange</strong> = Mat√©riel Reconditionn√© - Augmente ta vitesse (performance durable)
        </div>

        <div class="controls">
            <h3>‚öîÔ∏è Commandes</h3>
            <p>
                <strong>Fl√®ches directionnelles</strong> pour bouger Num√©rifix<br>
                <strong>Espace</strong> pour pause<br>
                <strong>R</strong> pour recommencer
            </p>
        </div>

        <div style="text-align: center; margin-top: 1.5rem;">
            <a href="/game" class="btn btn-secondary">‚Üê Retour au village NIRD</a>
        </div>
    </div>

    <div class="game-over" id="gameOver">
        <h2>üíÄ L'Empire Num√©rico a gagn√© !</h2>
        <p style="font-size: 1.2rem; margin: 1.5rem 0; color: #FFE4B5;">
            Tes donn√©es personnelles sont tomb√©es entre les mains des GAFAM...<br>
            <strong style="color: #E74C3C;">Souverainet√© perdue : 0%</strong><br>
            Score final : <span id="finalScore">0</span>
        </p>
        <p style="font-size: 0.95rem; color: #FFE4B5; font-style: italic; margin-top: 1rem;">
            üí° Dans la vraie vie : utilise des serveurs europ√©ens, des logiciels libres<br>
            et du mat√©riel reconditionn√© pour prot√©ger tes donn√©es !
        </p>
        <button class="btn btn-success" onclick="restartGame()">üîÑ Reconqu√©rir ma souverainet√©</button>
        <a href="/game" class="btn btn-secondary">‚Üê Retour</a>
    </div>

    <div class="game-win" id="gameWin">
        <h2>üéâ VICTOIRE GAULOISE !</h2>
        <p style="font-size: 1.2rem; margin: 1.5rem 0; color: #FFE4B5;">
            Toutes les donn√©es sont en s√©curit√© !<br>
            <strong style="color: #8BC34A;">üõ°Ô∏è Souverainet√© Num√©rique : 100% üõ°Ô∏è</strong><br>
            Score final : <span id="winScore">0</span>
        </p>
        <p style="font-size: 0.95rem; color: #FFE4B5; font-style: italic; margin-top: 1rem;">
            üåç Bravo ! Tu as compris l'importance de prot√©ger tes donn√©es.<br>
            Le NIRD, c'est r√©sister √† la surveillance et garder le contr√¥le !
        </p>
        <button class="btn btn-success" onclick="restartGame()">üîÑ Rejouer</button>
        <a href="/game" class="btn btn-secondary">‚Üê Retour</a>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        const CELL_SIZE = 30;
        const GRID_WIDTH = 19;
        const GRID_HEIGHT = 19;

        const BASE_PLAYER_SPEED = 0.12;
        const BASE_COLLECTOR_SPEED = 0.1;
        const VULNERABLE_COLLECTOR_SPEED = 0.07;
        const SPEED_BONUS_PLAYER = 0.2;

        const MAP = [
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
            [0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0],
            [0,3,0,0,1,0,0,0,1,0,1,0,0,0,1,0,0,3,0],
            [0,1,0,0,1,0,0,0,1,0,1,0,0,0,1,0,0,1,0],
            [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
            [0,1,0,0,1,0,1,0,0,0,0,0,1,0,1,0,0,1,0],
            [0,1,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,1,0],
            [0,0,0,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,0],
            [2,2,2,0,1,0,1,1,1,1,1,1,1,0,1,0,2,2,2],
            [0,0,0,0,1,0,1,0,2,2,2,0,1,0,1,0,0,0,0],
            [2,2,2,2,1,1,1,0,2,2,2,0,1,1,1,2,2,2,2],
            [0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,0,0,0],
            [2,2,2,0,1,0,1,1,1,2,1,1,1,0,1,0,2,2,2],
            [0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,0,0,0],
            [0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0],
            [0,1,0,0,1,0,0,0,1,0,1,0,0,0,1,0,0,1,0],
            [0,3,1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,3,0],
            [0,0,1,0,1,0,1,0,0,0,0,0,1,0,1,0,1,0,0],
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
        ];

        let gameMap = JSON.parse(JSON.stringify(MAP));

        let gameState = {
            score: 0,
            lives: 3,
            dataCollected: 0,
            totalData: 0,
            isPaused: false,
            gameOver: false,
            gameWon: false,
            bonusActive: null,
            bonusTimer: 0
        };

        let player = {
            x: 9,
            y: 14,
            targetX: 9,
            targetY: 14,
            direction: 'right',
            nextDirection: 'right',
            speed: BASE_PLAYER_SPEED,
            moving: false
        };

        let collectors = [
            { x: 8, y: 9, targetX: 8, targetY: 9, direction: 'left', color: '#DC143C', state: 'normal', name: 'Cloudus', moving: false },
            { x: 9, y: 9, targetX: 9, targetY: 9, direction: 'up', color: '#8B0000', state: 'normal', name: 'Databus', moving: false },
            { x: 10, y: 9, targetX: 10, targetY: 9, direction: 'right', color: '#B22222', state: 'normal', name: 'Trackus', moving: false }
        ];

        const BONUS_TYPES = {
            'serveur': { name: 'üîµ Serveur EU (RGPD)', color: '#4A90E2', effect: 'freeze', duration: 5000 },
            'libre': { name: 'üü¢ Logiciel Libre', color: '#8BC34A', effect: 'vulnerable', duration: 7000 },
            'recond': { name: 'üü† PC Reconditionn√©', color: '#FF9800', effect: 'speed', duration: 5000 }
        };

        function countTotalData() {
            let count = 0;
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    if (gameMap[y][x] === 1) count++;
                }
            }
            gameState.totalData = count;
        }

        function init() {
            countTotalData();
            updateStats();
            gameLoop();
        }

        function drawMaze() {
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    const cell = gameMap[y][x];
                    const px = x * CELL_SIZE;
                    const py = y * CELL_SIZE;

                    if (cell === 0) {
                        ctx.fillStyle = '#8B4513';
                        ctx.fillRect(px, py, CELL_SIZE, CELL_SIZE);
                        ctx.strokeStyle = '#654321';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(px, py, CELL_SIZE, CELL_SIZE);
                        
                        ctx.fillStyle = '#A0522D';
                        ctx.fillRect(px + 2, py + 2, 4, 4);
                        ctx.fillRect(px + CELL_SIZE - 6, py + CELL_SIZE - 6, 4, 4);
                    } else if (cell === 1) {
                        ctx.fillStyle = '#FFD700';
                        ctx.beginPath();
                        ctx.arc(px + CELL_SIZE / 2, py + CELL_SIZE / 2, 3, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.strokeStyle = '#FFA500';
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    } else if (cell === 3) {
                        const bonusTypes = Object.keys(BONUS_TYPES);
                        const bonusIndex = (x + y) % bonusTypes.length;
                        const bonus = BONUS_TYPES[bonusTypes[bonusIndex]];
                        
                        ctx.fillStyle = bonus.color;
                        ctx.beginPath();
                        const size = 8 + Math.sin(Date.now() / 200) * 2;
                        ctx.arc(px + CELL_SIZE / 2, py + CELL_SIZE / 2 + 2, size, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.fillStyle = '#8B4513';
                        ctx.fillRect(px + CELL_SIZE / 2 - 3, py + CELL_SIZE / 2 - size - 2, 6, 3);
                    }
                }
            }
        }

        function drawPlayer() {
            const px = player.x * CELL_SIZE;
            const py = player.y * CELL_SIZE;
            const cx = px + CELL_SIZE / 2;
            const cy = py + CELL_SIZE / 2;

            ctx.fillStyle = '#4A90E2';
            ctx.fillRect(cx - 8, cy - 2, 16, 12);
            
            ctx.fillStyle = '#FFDAB9';
            ctx.beginPath();
            ctx.arc(cx, cy - 8, 7, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(cx, cy - 8, 8, Math.PI, 0, true);
            ctx.fill();
            
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.ellipse(cx - 10, cy - 8, 4, 6, Math.PI / 4, 0, Math.PI * 2);
            ctx.ellipse(cx + 10, cy - 8, 4, 6, -Math.PI / 4, 0, Math.PI * 2);
            ctx.fill();

            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(cx - 3, cy - 5, 4, 0, Math.PI, false);
            ctx.arc(cx + 3, cy - 5, 4, 0, Math.PI, false);
            ctx.stroke();

            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.arc(cx - 3, cy - 9, 1.5, 0, Math.PI * 2);
            ctx.arc(cx + 3, cy - 9, 1.5, 0, Math.PI * 2);
            ctx.fill();

            if (player.direction === 'left') {
                ctx.fillStyle = '#8B4513';
                ctx.beginPath();
                ctx.arc(cx - 12, cy + 2, 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = 1;
                ctx.stroke();
            }
        }

        function drawCollectors() {
            collectors.forEach(collector => {
                let color = collector.color;
                let helmetColor = '#B8860B';
                
                if (collector.state === 'vulnerable') {
                    color = '#4A90E2';
                    helmetColor = '#4A90E2';
                } else if (collector.state === 'frozen') {
                    color = '#95A5A6';
                    helmetColor = '#7F8C8D';
                }

                const px = collector.x * CELL_SIZE;
                const py = collector.y * CELL_SIZE;
                const cx = px + CELL_SIZE / 2;
                const cy = py + CELL_SIZE / 2;

                ctx.fillStyle = color;
                ctx.fillRect(cx - 7, cy - 2, 14, 12);

                ctx.fillStyle = '#FFDAB9';
                ctx.beginPath();
                ctx.arc(cx, cy - 7, 6, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = helmetColor;
                ctx.beginPath();
                ctx.arc(cx, cy - 7, 7, Math.PI, 0, true);
                ctx.fill();
                
                ctx.fillStyle = '#DC143C';
                ctx.fillRect(cx - 1, cy - 14, 2, 7);

                ctx.fillStyle = '#000000';
                ctx.fillRect(cx - 4, cy - 8, 2, 2);
                ctx.fillRect(cx + 2, cy - 8, 2, 2);

                ctx.fillStyle = '#8B0000';
                ctx.beginPath();
                ctx.arc(cx + 10, cy + 2, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = 1;
                ctx.stroke();
            });
        }

        function canMove(x, y) {
            if (x < 0 || x >= GRID_WIDTH || y < 0 || y >= GRID_HEIGHT) return false;
            return gameMap[y][x] !== 0;
        }

        function movePlayer() {
            if (player.x !== player.targetX || player.y !== player.targetY) {
                const dx = player.targetX - player.x;
                const dy = player.targetY - player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist > player.speed) {
                    player.x += (dx / dist) * player.speed;
                    player.y += (dy / dist) * player.speed;
                } else {
                    player.x = player.targetX;
                    player.y = player.targetY;
                    player.moving = false;
                    
                    if (gameMap[player.y][player.x] === 1) {
                        gameMap[player.y][player.x] = 2;
                        gameState.dataCollected++;
                        gameState.score += 10;
                        updateStats();

                        if (gameState.dataCollected === gameState.totalData) {
                            winGame();
                        }
                    }

                    if (gameMap[player.y][player.x] === 3) {
                        gameMap[player.y][player.x] = 2;
                        activateBonus();
                        gameState.score += 50;
                        updateStats();
                    }
                }
            }

            if (!player.moving && player.x === player.targetX && player.y === player.targetY) {
                const dx = player.nextDirection === 'right' ? 1 : player.nextDirection === 'left' ? -1 : 0;
                const dy = player.nextDirection === 'down' ? 1 : player.nextDirection === 'up' ? -1 : 0;

                if (canMove(player.x + dx, player.y + dy)) {
                    player.direction = player.nextDirection;
                    player.targetX = player.x + dx;
                    player.targetY = player.y + dy;
                    player.moving = true;
                }
            }
        }

        function moveCollectors() {
            collectors.forEach(collector => {
                if (collector.state === 'frozen') return;

                if (!collector.moving && collector.x === collector.targetX && collector.y === collector.targetY) {
                    let chosenDirection = null;

                    if (Math.random() < 0.5) {
                        const dx = player.x - collector.x;
                        const dy = player.y - collector.y;
                        
                        if (Math.abs(dx) > Math.abs(dy)) {
                            chosenDirection = dx > 0 ? 'right' : 'left';
                        } else {
                            chosenDirection = dy > 0 ? 'down' : 'up';
                        }

                        const testDx = chosenDirection === 'right' ? 1 : chosenDirection === 'left' ? -1 : 0;
                        const testDy = chosenDirection === 'down' ? 1 : chosenDirection === 'up' ? -1 : 0;
                        const newX = collector.x + testDx;
                        const newY = collector.y + testDy;
                        
                        const collision = collectors.some(other => 
                            other !== collector && other.targetX === newX && other.targetY === newY
                        );

                        if (!canMove(newX, newY) || collision) {
                            chosenDirection = null;
                        }
                    }

                    if (chosenDirection === null) {
                        const directions = ['up', 'down', 'left', 'right'];
                        const validDirections = directions.filter(dir => {
                            const dx = dir === 'right' ? 1 : dir === 'left' ? -1 : 0;
                            const dy = dir === 'down' ? 1 : dir === 'up' ? -1 : 0;
                            const newX = collector.x + dx;
                            const newY = collector.y + dy;
                            
                            const collision = collectors.some(other => 
                                other !== collector && other.targetX === newX && other.targetY === newY
                            );
                            
                            return canMove(newX, newY) && !collision;
                        });

                        if (validDirections.length > 0) {
                            chosenDirection = validDirections[Math.floor(Math.random() * validDirections.length)];
                        }
                    }

                    if (chosenDirection) {
                        collector.direction = chosenDirection;
                        const dx = chosenDirection === 'right' ? 1 : chosenDirection === 'left' ? -1 : 0;
                        const dy = chosenDirection === 'down' ? 1 : chosenDirection === 'up' ? -1 : 0;
                        collector.targetX = collector.x + dx;
                        collector.targetY = collector.y + dy;
                        collector.moving = true;
                    }
                }

                if (collector.moving) {
                    const speed = collector.state === 'vulnerable' ? VULNERABLE_COLLECTOR_SPEED : BASE_COLLECTOR_SPEED;
                    const dx = collector.targetX - collector.x;
                    const dy = collector.targetY - collector.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist > speed) {
                        collector.x += (dx / dist) * speed;
                        collector.y += (dy / dist) * speed;
                    } else {
                        collector.x = collector.targetX;
                        collector.y = collector.targetY;
                        collector.moving = false;
                    }
                }
            });
        }

        function checkCollisions() {
            collectors.forEach(collector => {
                const dist = Math.sqrt(
                    Math.pow(collector.x - player.x, 2) + 
                    Math.pow(collector.y - player.y, 2)
                );

                if (dist < 0.5) {
                    if (collector.state === 'vulnerable') {
                        collector.x = 9;
                        collector.y = 9;
                        collector.targetX = 9;
                        collector.targetY = 9;
                        collector.state = 'normal';
                        collector.moving = false;
                        gameState.score += 200;
                        updateStats();
                    } else if (collector.state !== 'frozen') {
                        loseLife();
                    }
                }
            });
        }

        function activateBonus() {
            const bonusTypes = Object.keys(BONUS_TYPES);
            const randomBonus = bonusTypes[Math.floor(Math.random() * bonusTypes.length)];
            const bonus = BONUS_TYPES[randomBonus];

            gameState.bonusActive = bonus;
            gameState.bonusTimer = bonus.duration;

            const indicator = document.getElementById('bonusIndicator');
            indicator.textContent = bonus.name + ' activ√© !';
            indicator.style.display = 'block';
            indicator.style.background = `rgba(${hexToRgb(bonus.color)}, 0.95)`;

            collectors.forEach(c => {
                if (bonus.effect === 'freeze') c.state = 'frozen';
                if (bonus.effect === 'vulnerable') c.state = 'vulnerable';
            });

            if (bonus.effect === 'speed') {
                player.speed = SPEED_BONUS_PLAYER;
            }

            setTimeout(() => {
                gameState.bonusActive = null;
                indicator.style.display = 'none';
                collectors.forEach(c => c.state = 'normal');
                player.speed = BASE_PLAYER_SPEED;
            }, bonus.duration);
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? 
                `${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)}` : '0,0,0';
        }

        function loseLife() {
            gameState.lives--;
            updateStats();

            if (gameState.lives <= 0) {
                endGame();
            } else {
                player.x = 9;
                player.y = 14;
                player.targetX = 9;
                player.targetY = 14;
                player.moving = false;
                player.speed = BASE_PLAYER_SPEED;
                
                collectors.forEach((c, i) => {
                    c.x = 8 + i;
                    c.y = 9;
                    c.targetX = 8 + i;
                    c.targetY = 9;
                    c.moving = false;
                    c.state = 'normal';
                });
            }
        }

        function endGame() {
            gameState.gameOver = true;
            document.getElementById('finalScore').textContent = gameState.score;
            document.getElementById('gameOver').style.display = 'block';
        }

        function winGame() {
            gameState.gameWon = true;
            document.getElementById('winScore').textContent = gameState.score;
            document.getElementById('gameWin').style.display = 'block';
        }

        function updateStats() {
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('dataCount').textContent = 
                `${gameState.dataCollected}/${gameState.totalData}`;

            const livesContainer = document.getElementById('lives');
            livesContainer.innerHTML = '';
            for (let i = 0; i < gameState.lives; i++) {
                const icon = document.createElement('div');
                icon.className = 'life-icon';
                livesContainer.appendChild(icon);
            }
        }

        function gameLoop() {
            if (!gameState.isPaused && !gameState.gameOver && !gameState.gameWon) {
                drawMaze();
                drawCollectors();
                drawPlayer();
                movePlayer();
                moveCollectors();
                checkCollisions();
            }

            requestAnimationFrame(gameLoop);
        }

        document.addEventListener('keydown', (e) => {
            if (e.code === 'ArrowUp') {
                player.nextDirection = 'up';
                e.preventDefault();
            } else if (e.code === 'ArrowDown') {
                player.nextDirection = 'down';
                e.preventDefault();
            } else if (e.code === 'ArrowLeft') {
                player.nextDirection = 'left';
                e.preventDefault();
            } else if (e.code === 'ArrowRight') {
                player.nextDirection = 'right';
                e.preventDefault();
            } else if (e.code === 'Space') {
                gameState.isPaused = !gameState.isPaused;
                e.preventDefault();
            } else if (e.code === 'KeyR') {
                restartGame();
            }
        });

        function restartGame() {
            gameMap = JSON.parse(JSON.stringify(MAP));
            
            gameState = {
                score: 0,
                lives: 3,
                dataCollected: 0,
                totalData: 0,
                isPaused: false,
                gameOver: false,
                gameWon: false,
                bonusActive: null,
                bonusTimer: 0
            };
            
            player = {
                x: 9,
                y: 14,
                targetX: 9,
                targetY: 14,
                direction: 'right',
                nextDirection: 'right',
                speed: BASE_PLAYER_SPEED,
                moving: false
            };
            
            collectors = [
                { x: 8, y: 9, targetX: 8, targetY: 9, direction: 'left', color: '#DC143C', state: 'normal', name: 'Cloudus', moving: false },
                { x: 9, y: 9, targetX: 9, targetY: 9, direction: 'up', color: '#8B0000', state: 'normal', name: 'Databus', moving: false },
                { x: 10, y: 9, targetX: 10, targetY: 9, direction: 'right', color: '#B22222', state: 'normal', name: 'Trackus', moving: false }
            ];
            
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('gameWin').style.display = 'none';
            document.getElementById('bonusIndicator').style.display = 'none';
            
            countTotalData();
            updateStats();
        }

        init();
    </script>
</body>
</html>